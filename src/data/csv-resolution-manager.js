// src/data/csv-resolution-manager.js - CSV-based Multi-Resolution Data Manager
// Manages zoom-level dependent data loading from CSV resolution files
// Supports: seconds (1s bins), milliseconds (1ms bins), raw (microsecond packets)

/**
 * LRU Cache for storing loaded chunks
 */
class LRUCache {
    constructor(maxSize = 50) {
        this.maxSize = maxSize;
        this.cache = new Map();
    }

    get(key) {
        if (!this.cache.has(key)) return undefined;
        const value = this.cache.get(key);
        this.cache.delete(key);
        this.cache.set(key, value);
        return value;
    }

    set(key, value) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        } else if (this.cache.size >= this.maxSize) {
            const oldest = this.cache.keys().next().value;
            this.cache.delete(oldest);
        }
        this.cache.set(key, value);
    }

    has(key) {
        return this.cache.has(key);
    }

    clear() {
        this.cache.clear();
    }

    get size() {
        return this.cache.size;
    }
}

/**
 * Resolution thresholds in microseconds
 * These determine which data resolution to use based on visible time range
 */
const RESOLUTION_THRESHOLDS = {
    // If visible range > 60 seconds, use second-level aggregates
    SECONDS: 60 * 1_000_000,  // 60 seconds in microseconds

    // If visible range 1s - 60s, use millisecond-level aggregation
    MILLISECONDS: 1 * 1_000_000,  // 1 second in microseconds

    // If visible range < 1 second, show raw microsecond packets
    RAW: 0
};

/**
 * Resolution levels
 */
const RESOLUTION = {
    SECONDS: 'seconds',
    MILLISECONDS: 'milliseconds',
    RAW: 'raw'
};

/**
 * CSV-based Multi-Resolution Data Manager
 * Reads from resolution folder structure generated by Python script
 */
export class CSVResolutionManager {
    constructor() {
        // Folder handle for File System Access API
        this.folderHandle = null;
        this.resolutionsHandle = null;

        // Index data from index.json files
        this.secondsIndex = null;
        this.millisecondsIndex = null;
        this.rawIndex = null;

        // Cached data
        this.secondsData = null;  // Full seconds data (small, loaded once)
        this.millisecondsCache = new LRUCache(30);  // Chunk cache
        this.rawCache = new LRUCache(50);  // Chunk cache

        // Loading state
        this.loadingChunks = new Set();

        // Current state
        this.currentResolution = RESOLUTION.SECONDS;
        this.timeExtent = null;

        // Hysteresis to prevent flickering
        this.lastSwitchTime = 0;
        this.MIN_SWITCH_INTERVAL_MS = 100;

        // Callbacks
        this.onResolutionChange = null;
        this.onLoadingStart = null;
        this.onLoadingEnd = null;
    }

    /**
     * Initialize the resolution manager with a folder handle
     * @param {FileSystemDirectoryHandle} folderHandle - Folder containing resolutions/
     * @returns {Promise<Array>} Initial seconds-level data
     */
    async init(folderHandle) {
        this.folderHandle = folderHandle;

        console.log('[CSVResManager] Initializing...');

        try {
            // Get resolutions directory handle
            this.resolutionsHandle = await folderHandle.getDirectoryHandle('resolutions');

            // Load all index files
            await this._loadIndices();

            // Load seconds data (small, always in memory)
            await this._loadSecondsData();

            console.log(`[CSVResManager] Initialized with ${this.secondsData?.length || 0} second bins`);

            return this.secondsData;
        } catch (err) {
            console.error('[CSVResManager] Initialization failed:', err);
            throw err;
        }
    }

    /**
     * Load all resolution index files
     * @private
     */
    async _loadIndices() {
        try {
            // Load seconds index
            const secondsDir = await this.resolutionsHandle.getDirectoryHandle('seconds');
            const secondsIndexFile = await secondsDir.getFileHandle('index.json');
            const secondsIndexData = await (await secondsIndexFile.getFile()).text();
            this.secondsIndex = JSON.parse(secondsIndexData);
            console.log(`[CSVResManager] Loaded seconds index: ${this.secondsIndex.total_count} bins`);

            // Set time extent from seconds index
            this.timeExtent = [
                this.secondsIndex.time_range.start,
                this.secondsIndex.time_range.end
            ];
        } catch (err) {
            console.warn('[CSVResManager] Failed to load seconds index:', err);
        }

        try {
            // Load milliseconds index
            const msDir = await this.resolutionsHandle.getDirectoryHandle('milliseconds');
            const msIndexFile = await msDir.getFileHandle('index.json');
            const msIndexData = await (await msIndexFile.getFile()).text();
            this.millisecondsIndex = JSON.parse(msIndexData);
            console.log(`[CSVResManager] Loaded milliseconds index: ${this.millisecondsIndex.chunks?.length || 0} chunks`);
        } catch (err) {
            console.warn('[CSVResManager] Failed to load milliseconds index:', err);
        }

        try {
            // Load raw index
            const rawDir = await this.resolutionsHandle.getDirectoryHandle('raw');
            const rawIndexFile = await rawDir.getFileHandle('index.json');
            const rawIndexData = await (await rawIndexFile.getFile()).text();
            this.rawIndex = JSON.parse(rawIndexData);
            console.log(`[CSVResManager] Loaded raw index: ${this.rawIndex.chunks?.length || 0} chunks`);
        } catch (err) {
            console.warn('[CSVResManager] Failed to load raw index:', err);
        }
    }

    /**
     * Load seconds-level data (small, loaded once)
     * @private
     */
    async _loadSecondsData() {
        if (!this.secondsIndex) return;

        try {
            const secondsDir = await this.resolutionsHandle.getDirectoryHandle('seconds');
            const dataFile = await secondsDir.getFileHandle(this.secondsIndex.data_file || 'data.csv');
            const csvText = await (await dataFile.getFile()).text();

            this.secondsData = this._parseCSV(csvText);
            console.log(`[CSVResManager] Loaded ${this.secondsData.length} seconds bins`);
        } catch (err) {
            console.error('[CSVResManager] Failed to load seconds data:', err);
            this.secondsData = [];
        }
    }

    /**
     * Parse CSV text into array of objects
     * @private
     */
    _parseCSV(csvText) {
        const lines = csvText.split('\n').filter(line => line.trim());
        if (lines.length < 2) return [];

        const headers = lines[0].split(',').map(h => h.trim());
        const data = [];

        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(',');
            if (values.length < headers.length) continue;

            const row = {};
            for (let j = 0; j < headers.length; j++) {
                const header = headers[j];
                let value = values[j]?.trim() || '';

                // Type conversion
                if (['timestamp', 'bin_start', 'bin_end', 'count', 'total_bytes'].includes(header)) {
                    value = parseInt(value) || 0;
                }

                row[header] = value;
            }

            // Add binned flag and compute additional properties
            row.binned = true;
            row.binStart = row.bin_start || row.timestamp;
            row.binEnd = row.bin_end || row.timestamp + 1_000_000;
            row.binCenter = Math.floor((row.binStart + row.binEnd) / 2);
            row.flagType = row.flag_type || 'OTHER';
            row.preBinnedSize = row.binEnd - row.binStart;  // Mark as pre-binned for visualization
            row.resolution = this.currentResolution;

            data.push(row);
        }

        return data;
    }

    /**
     * Get the required resolution for a given visible time range
     * @param {number} visibleRange - Time range in microseconds
     * @returns {string} Resolution level
     */
    getResolutionForRange(visibleRange) {
        const now = performance.now();
        const timeSinceLastSwitch = now - this.lastSwitchTime;

        let targetResolution;
        if (visibleRange > RESOLUTION_THRESHOLDS.SECONDS) {
            targetResolution = RESOLUTION.SECONDS;
        } else if (visibleRange > RESOLUTION_THRESHOLDS.MILLISECONDS) {
            targetResolution = RESOLUTION.MILLISECONDS;
        } else {
            targetResolution = RESOLUTION.RAW;
        }

        // Apply minimum switch interval to prevent flickering
        if (targetResolution !== this.currentResolution) {
            if (timeSinceLastSwitch < this.MIN_SWITCH_INTERVAL_MS) {
                return this.currentResolution;
            }
            this.lastSwitchTime = now;
            console.log(`[CSVResManager] Resolution: ${this.currentResolution} -> ${targetResolution}`);
            this.currentResolution = targetResolution;
        }

        return targetResolution;
    }

    /**
     * Get resolution info including transition state
     * @param {number} visibleRange - Time range in microseconds
     * @returns {Object} Resolution info
     */
    getResolutionInfo(visibleRange) {
        const previousResolution = this.currentResolution;
        const resolution = this.getResolutionForRange(visibleRange);

        return {
            resolution,
            switchedResolution: resolution !== previousResolution,
            transitionProgress: 0,
            shouldPrefetch: false,
            prefetchResolution: null
        };
    }

    /**
     * Get data for the current domain with non-blocking loading
     * @param {[number, number]} domain - [startTime, endTime] in microseconds
     * @returns {Promise<Object>} { data, resolution, isLoading, loadingPromise }
     */
    async getDataForDomainNonBlocking(domain) {
        const [start, end] = domain;
        const visibleRange = end - start;

        const resInfo = this.getResolutionInfo(visibleRange);
        const requiredResolution = resInfo.resolution;

        console.log(`[CSVResManager] Getting data for [${start}, ${end}], range=${(visibleRange/1_000_000).toFixed(2)}s, res=${requiredResolution}`);

        // Get immediate data
        let immediateData = await this._getImmediateData(domain, requiredResolution);
        let isLoading = false;
        let loadingPromise = null;

        // Check if we need to load chunk data
        if (requiredResolution === RESOLUTION.MILLISECONDS || requiredResolution === RESOLUTION.RAW) {
            const missingChunks = this._getMissingChunks(domain, requiredResolution);

            if (missingChunks.length > 0) {
                isLoading = true;
                loadingPromise = this._loadChunks(missingChunks, requiredResolution, domain);
            }
        }

        if (resInfo.switchedResolution && this.onResolutionChange) {
            this.onResolutionChange(requiredResolution, resInfo);
        }

        return {
            data: immediateData,
            resolution: requiredResolution,
            isLoading,
            loadingPromise,
            transitionInfo: resInfo
        };
    }

    /**
     * Get best available data immediately without blocking
     * @private
     */
    async _getImmediateData(domain, targetResolution) {
        const [start, end] = domain;

        if (targetResolution === RESOLUTION.SECONDS && this.secondsData) {
            return this.secondsData.filter(d => {
                const t = d.binStart || d.timestamp;
                return t >= start && t <= end;
            });
        }

        if (targetResolution === RESOLUTION.MILLISECONDS) {
            const cachedData = this._assembleFromCache(domain, this.millisecondsCache, this.millisecondsIndex);
            if (cachedData.length > 0) return cachedData;
        }

        if (targetResolution === RESOLUTION.RAW) {
            const cachedData = this._assembleFromCache(domain, this.rawCache, this.rawIndex);
            if (cachedData.length > 0) return cachedData;
        }

        // Fall back to seconds data
        if (this.secondsData) {
            return this.secondsData.filter(d => {
                const t = d.binStart || d.timestamp;
                return t >= start && t <= end;
            });
        }

        return [];
    }

    /**
     * Get chunks that need to be loaded for the domain
     * @private
     */
    _getMissingChunks(domain, resolution) {
        const [start, end] = domain;
        const index = resolution === RESOLUTION.MILLISECONDS ? this.millisecondsIndex : this.rawIndex;
        const cache = resolution === RESOLUTION.MILLISECONDS ? this.millisecondsCache : this.rawCache;

        if (!index || !index.chunks) return [];

        const missing = [];
        for (const chunk of index.chunks) {
            // Check if chunk overlaps with domain
            if (chunk.end < start || chunk.start > end) continue;

            // Check if chunk is already cached or loading
            if (!cache.has(chunk.file) && !this.loadingChunks.has(chunk.file)) {
                missing.push(chunk);
            }
        }

        return missing;
    }

    /**
     * Load chunks and return assembled data
     * @private
     */
    async _loadChunks(chunks, resolution, domain) {
        if (chunks.length === 0) return [];

        if (this.onLoadingStart) this.onLoadingStart();

        const dirName = resolution === RESOLUTION.MILLISECONDS ? 'milliseconds' : 'raw';
        const cache = resolution === RESOLUTION.MILLISECONDS ? this.millisecondsCache : this.rawCache;

        try {
            const resDir = await this.resolutionsHandle.getDirectoryHandle(dirName);

            // Load chunks in parallel
            await Promise.all(chunks.map(async (chunk) => {
                if (this.loadingChunks.has(chunk.file)) return;
                this.loadingChunks.add(chunk.file);

                try {
                    const file = await resDir.getFileHandle(chunk.file);
                    const csvText = await (await file.getFile()).text();
                    const data = this._parseCSV(csvText);
                    cache.set(chunk.file, data);
                    console.log(`[CSVResManager] Loaded ${chunk.file}: ${data.length} items`);
                } catch (err) {
                    console.error(`[CSVResManager] Failed to load ${chunk.file}:`, err);
                } finally {
                    this.loadingChunks.delete(chunk.file);
                }
            }));

            // Assemble and return data
            const index = resolution === RESOLUTION.MILLISECONDS ? this.millisecondsIndex : this.rawIndex;
            return this._assembleFromCache(domain, cache, index);

        } finally {
            if (this.onLoadingEnd) this.onLoadingEnd();
        }
    }

    /**
     * Assemble data from cache for a domain
     * @private
     */
    _assembleFromCache(domain, cache, index) {
        if (!index || !index.chunks) return [];

        const [start, end] = domain;
        const allData = [];

        for (const chunk of index.chunks) {
            // Check if chunk overlaps with domain
            if (chunk.end < start || chunk.start > end) continue;

            const chunkData = cache.get(chunk.file);
            if (chunkData) {
                // Filter to exact domain
                const filtered = chunkData.filter(d => {
                    const t = d.binStart || d.timestamp;
                    return t >= start && t <= end;
                });
                allData.push(...filtered);
            }
        }

        // Sort by timestamp
        allData.sort((a, b) => (a.timestamp || a.binStart) - (b.timestamp || b.binStart));

        return allData;
    }

    /**
     * Get memory stats
     */
    getMemoryStats() {
        return {
            secondsCount: this.secondsData?.length || 0,
            millisecondsCacheChunks: this.millisecondsCache.size,
            rawCacheChunks: this.rawCache.size,
            loadingChunks: this.loadingChunks.size
        };
    }

    /**
     * Clear all cached data
     */
    clear() {
        this.secondsData = null;
        this.millisecondsCache.clear();
        this.rawCache.clear();
        this.loadingChunks.clear();
        this.currentResolution = RESOLUTION.SECONDS;
    }
}

// Export constants
export { RESOLUTION, RESOLUTION_THRESHOLDS };

// Export singleton instance
export const csvResolutionManager = new CSVResolutionManager();
